\chapter{Conclusion}
\label{sec:conclusion}

This thesis presented the implementation and evaluation of a Bitcoin-like system based on the Prism consensus protocol. Our implementation supports over 70,000 transactions per second at a confirmation latency of tens of seconds with Bitcoin-level security. Our results validate the theoretical analysis of the Prism protocol, and highlight the importance of optimizing transaction execution and the databases for high throughput.   We also demonstrated experimentally that Prism is robust to several active attacks, and showed that a simple jittering approach is effective at mitigating spamming. 

There are several avenues for future work. Our current implementation uses a UTXO-based scripting layer, and extending it to a more complex scripting layer for smart contracts is of interest.  As described in \S\ref{sec:scoreboarding}, parallelizing transaction execution (via \textit{scoreboarding}) was vital in achieving high throughput. The ability to parallelize transaction execution for smart contracts will  be  key to exploiting the high throughput provided by \prism consensus. Other extensions include methods to bootstrap new users and support light clients who only download the block headers (but not full blocks). Efficient bootstrapping is particularly important in a protocol like Prism that operates near network capacity, since expecting a new user to download and process all the old blocks is not practical. 

%An interesting direction is to store all the unspent coins in the ledger formed by leader blocks until level $\ell$ in a Merkle-Patricia tree and add the root of this tree to the proposer block(s) at level $\ell+e$ (for a large value of $e$, say $20$). Since this tree contains only unspent coins generated by valid transactions, it provides a snapshot of the state of the ledger until level $\ell$.  

\if 0
the merkle proof of the output coins of a payment with respect to to this commit proves the validity of the payment. 

 A natural question is whether we can achieve similar performance on a smart contract layer. 
 \prism's latency depends only on the block structure at the consensus layer and is independent of the scripting layer. Thus a smart contract version of Prism will also achieve low confirmation latency. 

% \smallskip
\noindent \textbf{Light clients.} 
 SPV (Simple payment verification) are short proofs~\cite{spv} to verify the validity of a given transaction (payment) for a \textit{light user} who only downloads the blocks headers in a blockchain.
In the longest chain protocol, every transaction in the block is valid so a Merkle proof of a transaction with respect to its block header proves payment validity.
However, this is not enough in \prism, where transaction blocks can potentially contain invalid transactions. We can facilitate SPV proofs in \prism by this simple modification: We store all the unspent coins in the ledger formed by leader blocks until level $\ell$ in a Merkle-Patricia tree and add the root of this tree to the proposer block(s) at level $\ell+e$ (for a large value of $e$, say $20$). Since this tree contains only unspent coins generated by valid transactions, the merkle proof of the output coins of a payment with respect to to this commit proves the validity of the payment.

% \smallskip
\noindent \textbf{Bootstrapping a new user.} 
Longest chain blockchains like Bitcoin use a small fraction of network bandwidth, so new users can simply download and process all the blocks to join the system. 
Since Prism runs near network capacity,  expecting a new user to download and process all the old blocks is not practical. 
The modification suggested in the previous paragraph can be also used to bootstrap as follows: a new user downloads all proposer and voter tree blocks (which consume less than $0.1\%$ of the capacity). Say the new user's proposer tree has confirmed leader block at level $\ell$. 
We know that this leader block stores the commit of all the unspent coins up to level $\ell-e$. 
Now the new user asks an existing user for the UTXO set for the ledger up to level $\ell-e$. The user can verify the correctness of this set by comparing it with the UTXO set commitment stored in the leader block at level $\ell$.
% \gw{"the commit of stored the leader block" contains a typo?}
This UTXO set contains all the information required from transaction blocks
% \gw{can we abbr transaction to tx?}
referred by proposer blocks until level $\ell-e$ and thus the new user can join the system by downloading full blocks starting from level $\ell-e$.



\noindent \textbf{Smart contracts.} 
 Our current implementation achieves high throughput and low latency on an UTXO based scripting layer. 
 A natural question is whether we can achieve similar performance on a smart contract layer. 
 \prism's latency depends only on the block structure at the consensus layer and is independent of the scripting layer. Thus a smart contract version of Prism will also achieve low confirmation latency. As described in \S\ref{sec:scoreboarding}, parallelizing transaction execution (via \textit{scoreboarding}) was vital in achieving high throughput. The ability to parallelize transaction execution of smart contracts will also be the key to exploit the high throughput provided by \prism consensus. 
 
\fi
